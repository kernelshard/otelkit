<p>package otelkit // import “github.com/samims/otelkit”</p>
<p>Package otelkit provides HTTP middleware for automatic request
tracing. The middleware integrates seamlessly with any HTTP framework
that supports the standard http.Handler interface, including
gorilla/mux, chi, gin, echo, and others.</p>
<p>Package otelkit provides OpenTelemetry tracer provider configuration
and initialization. This file contains the core provider setup that
configures exporters, sampling, resource identification, and batch
processing for the entire tracing system.</p>
<p>Package tracer provides span utility functions for OpenTelemetry
tracing. These utilities offer safe, convenient methods for common span
operations with built-in nil checks and error handling.</p>
<p>CONSTANTS</p>
<p>const ( DefaultServiceName = “unknown-service” DefaultServiceVersion
= “1.0.0” DefaultEnvironment = “development” DefaultOTLPExporterEndpoint
= “localhost:4317” DefaultSamplingRatio = 0.2 DefaultSamplingType =
“probabilistic” DefaultOTLPExporterProtocol = “grpc” DefaultBatchTimeout
= 5 * time.Second DefaultExportTimeout = 30 * time.Second
DefaultMaxExportBatchSize = 512 DefaultMaxQueueSize = 2048 ) Service
configuration constants</p>
<p>const ( AttrHTTPMethod = “http.method” AttrHTTPURL = “http.url”
AttrHTTPUserAgent = “http.user_agent” AttrHTTPStatusCode =
“http.status_code” ) OpenTelemetry semantic convention constants</p>
<p>const ( ErrServiceNameRequired = “service name is required”
ErrServiceVersionRequired = “service version is required”
ErrInvalidEnvironment = “invalid environment” ErrInvalidSamplingType =
“invalid sampling type” ErrInvalidSamplingRatio = “sampling ratio must
be between 0 and 1” ErrInvalidExporterProtocol = “invalid exporter
protocol” ErrInvalidExporterEndpoint = “exporter endpoint is required” )
Error message constants</p>
<p>const ( EnvServiceName = “OTEL_SERVICE_NAME” EnvServiceVersion =
“OTEL_SERVICE_VERSION” EnvEnvironment = “OTEL_ENVIRONMENT”
EnvOTLPExporterEndpoint = “OTEL_EXPORTER_OTLP_ENDPOINT”
EnvOTLPExporterInsecure = “OTEL_EXPORTER_OTLP_INSECURE”
EnvOTLPExporterProtocol = “OTEL_EXPORTER_OTLP_PROTOCOL” EnvBatchTimeout
= “OTEL_BSP_TIMEOUT” EnvExportTimeout = “OTEL_EXPORTER_TIMEOUT”
EnvMaxExportBatchSize = “OTEL_BSP_MAX_EXPORT_BATCH_SIZE” EnvMaxQueueSize
= “OTEL_BSP_MAX_QUEUE_SIZE” EnvSamplingType = “OTEL_TRACES_SAMPLER”
EnvSamplingRatio = “OTEL_TRACES_SAMPLER_ARG” EnvInstanceID =
“OTEL_RESOURCE_ATTRIBUTES_SERVICE_INSTANCE_ID” ) Environment variable
constants</p>
<p>VARIABLES</p>
<p>var ( ValidEnvironments = []string{“development”, “staging”,
“production”} ValidSamplingTypes = []string{“probabilistic”,
“always_on”, “always_off”} ValidHTTPMethods = []string{ http.MethodHead,
http.MethodPost, http.MethodPut, http.MethodDelete, http.MethodPatch,
http.MethodHead, http.MethodOptions, } ValidOTLPProtocols =
[]string{“grpc”, “http”} ) Valid configuration options</p>
<p>FUNCTIONS</p>
<p>func AddAttributes(span trace.Span, attrs …attribute.KeyValue)
AddAttributes safely adds one or more attributes to the given span. If
the span is nil, this function is a no-op. This is useful for adding
contextual information to spans such as user IDs, request parameters, or
business logic details.</p>
<pre><code>Example:

    AddAttributes(span,
        attribute.String(&quot;user.id&quot;, &quot;12345&quot;),
        attribute.Int(&quot;request.size&quot;, 1024),
        attribute.Bool(&quot;cache.hit&quot;, true),
    )</code></pre>
<p>func AddEvent(span trace.Span, name string, attrs
…attribute.KeyValue) AddEvent safely adds a named event with optional
attributes to the span. Events are timestamped markers that can help
understand the flow of execution. If the span is nil, this function is a
no-op.</p>
<pre><code>Example:

    AddEvent(span, &quot;cache.miss&quot;,
        attribute.String(&quot;key&quot;, cacheKey),
        attribute.String(&quot;reason&quot;, &quot;expired&quot;),
    )</code></pre>
<p>func AddTimedEvent(span trace.Span, name string, duration
time.Duration) AddTimedEvent adds an event with duration information to
the span. This is useful for recording the time taken for specific
operations within a larger span. The duration is added as a string
attribute.</p>
<pre><code>Example:

    start := time.Now()
    // ... perform operation
    AddTimedEvent(span, &quot;database.query&quot;, time.Since(start))</code></pre>
<p>func EndSpan(span trace.Span) EndSpan safely ends the given span. If
the span is nil, this function is a no-op. This provides a safe way to
end spans without worrying about nil checks.</p>
<pre><code>Example:

    defer EndSpan(span)</code></pre>
<p>func ExtractTraceContext(req *http.Request) context.Context
ExtractTraceContext extracts trace context from HTTP request headers
into the context.</p>
<p>func InjectTraceContext(ctx context.Context, req *http.Request)
InjectTraceContext injects the current trace context into the HTTP
request headers.</p>
<p>func InjectTraceIDIntoContext(ctx context.Context, span trace.Span)
context.Context InjectTraceIDIntoContext adds trace ID into the context
(as a new value).</p>
<p>func IsRecording(span trace.Span) bool IsRecording checks if the span
is currently recording telemetry data. Returns false if the span is nil
or if the span context is invalid. This can be used to avoid expensive
operations when tracing is disabled or when working with noop spans.</p>
<pre><code>Example:

    if IsRecording(span) {
        // Perform expensive attribute computation
        span.SetAttributes(expensiveAttributes()...)
    }</code></pre>
<p>func MustSetupTracing(ctx context.Context, serviceName string,
serviceVersion …string) func(context.Context) error MustSetupTracing is
like SetupTracing but panics on error. Use this for simple programs
where you want to fail fast.</p>
<p>func NewConfigError(field, message string) error NewConfigError
creates a new ConfigError.</p>
<p>func NewDefaultProvider(ctx context.Context, serviceName string,
serviceVersion …string) (*sdktrace.TracerProvider, error)
NewDefaultProvider creates a tracer provider with default settings and
sets it as the global provider. This is a convenience function for quick
setup in development or simple applications. It creates a provider with
opinionated defaults: - HTTP OTLP exporter to localhost:4318 (insecure)
- Probabilistic sampling at the default rate (typically 20%) - Standard
batch processing settings - Automatic resource detection for service
identification</p>
<pre><code>The provider is set as the global OpenTelemetry provider (only once per
application). For production use or when you need custom configuration,
use NewProvider with NewProviderConfig.

Note: This is the function most users will start with. It&#39;s designed to
&quot;just work&quot; for local development and testing scenarios.

Example:

    provider, err := tracer.NewDefaultProvider(ctx, &quot;my-service&quot;, &quot;v1.0.0&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer provider.Shutdown(ctx)</code></pre>
<p>func NewInitializationError(component string, cause error) error
NewInitializationError creates a new InitializationError.</p>
<p>func NewInstrumentedGRPCClientDialOptions() []grpc.DialOption
NewInstrumentedGRPCClientDialOptions returns grpc.DialOption slice with
OpenTelemetry instrumentation for client connections. Use this in
grpc.Dial for instrumented client connections.</p>
<p>func NewInstrumentedGRPCServer(opts …grpc.ServerOption) *grpc.Server
NewInstrumentedGRPCServer creates a new gRPC server with OpenTelemetry
unary and stream interceptors attached automatically.</p>
<p>func NewInstrumentedHTTPClient(baseTransport http.RoundTripper)
<em>http.Client NewInstrumentedHTTPClient returns an </em>http.Client
with OpenTelemetry transport for automatic HTTP tracing. You can
customize it by passing a base transport; if nil, http.DefaultTransport
is used.</p>
<p>func NewInstrumentedHTTPHandler(handler http.Handler, operationName
string) http.Handler NewInstrumentedHTTPHandler wraps an http.Handler
with OpenTelemetry instrumentation and returns the wrapped handler.
Usage: http.Handle(“/path”, NewInstrumentedHTTPHandler(yourHandler,
“operationName”))</p>
<p>func NewPropagationError(operation string, cause error) error
NewPropagationError creates a new PropagationError.</p>
<p>func NewProvider(ctx context.Context, cfg <em>ProviderConfig)
(</em>sdktrace.TracerProvider, error) NewProvider creates and configures
a new TracerProvider using the provided configuration, then sets it as
the global OpenTelemetry provider (only once per application lifecycle).
This is the recommended way to initialize tracing when you need custom
configuration.</p>
<pre><code>The function ensures that the global provider is set only once, even if
called multiple times. This prevents conflicts and ensures consistent
tracing behavior across the application.

Example:

    config := tracer.NewProviderConfig(&quot;payment-service&quot;, &quot;v1.2.3&quot;).
        WithOTLPExporter(&quot;https://api.honeycomb.io&quot;, &quot;http&quot;, false).
        WithSampling(&quot;probabilistic&quot;, 0.05)

    provider, err := tracer.NewProvider(ctx, config)
    if err != nil {
        log.Fatal(err)
    }
    defer provider.Shutdown(ctx)</code></pre>
<p>func RecordError(span trace.Span, err error) RecordError safely
records an error on the span and sets the span status to error. This
function handles nil checks for both span and error. When an error is
recorded, the span status is automatically set to codes.Error with the
error message. This is essential for proper error tracking in
distributed tracing.</p>
<pre><code>Example:

    if err := doSomething(); err != nil {
        RecordError(span, err)
        return err
    }</code></pre>
<p>func SetGlobalTracerProvider(tp trace.TracerProvider)
SetGlobalTracerProvider sets the global OpenTelemetry tracer provider.
This should typically be called once during application initialization.
All subsequent tracer instances will use this provider.</p>
<pre><code>Example:

    provider := setupTracerProvider()
    tracer.SetGlobalTracerProvider(provider)</code></pre>
<p>func SetupCustomTracing(ctx context.Context, cfg <em>ProviderConfig)
(</em>sdktrace.TracerProvider, error) SetupCustomTracing provides full
control over the tracing setup. Use this when you need custom
configuration that goes beyond environment variables.</p>
<p>func SetupTracing(ctx context.Context, serviceName string,
serviceVersion …string) (func(context.Context) error, error)
SetupTracing initializes OpenTelemetry tracing with sensible defaults.
This is the simplest way to get started with tracing.</p>
<pre><code>Example:

    shutdown, err := tracer.SetupTracing(ctx, &quot;my-service&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer shutdown(ctx)

The function reads configuration from environment variables and sets up:
- OTLP exporter (HTTP by default, localhost:4318) - Probabilistic sampling
(20% by default) - Batch span processor with sensible defaults - Resource
with service information</code></pre>
<p>func SetupTracingWithDefaults(ctx context.Context, serviceName,
serviceVersion string) (func(context.Context) error, error)
SetupTracingWithDefaults initializes tracing with hardcoded defaults.
This is useful for quick setup without environment variables.</p>
<pre><code>It uses: - HTTP OTLP exporter to localhost:4318 (insecure) - Probabilistic
sampling at 20% - Standard batch processing settings</code></pre>
<p>func ShutdownTracerProvider(ctx context.Context, tp
*sdktrace.TracerProvider) error ShutdownTracerProvider gracefully shuts
down the tracer provider, ensuring all pending spans are exported before
the application terminates. This function should be called during
application shutdown, typically with a context that has a reasonable
timeout.</p>
<pre><code>The shutdown process:
 1. Stops accepting new spans
 2. Exports all remaining spans in the queue
 3. Closes the exporter connection
 4. Releases any resources held by the provider

Example:

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := tracer.ShutdownTracerProvider(ctx, provider); err != nil {
        log.Printf(&quot;Error during tracer shutdown: %v&quot;, err)
    }</code></pre>
<p>func TraceIDFromContext(ctx context.Context) string
TraceIDFromContext tries to retrieve trace ID from context.</p>
<p>TYPES</p>
<p>type Config struct { // Service identification metadata ServiceName
string // Name of the service (required) ServiceVersion string //
Version of the service (required) Environment string // Deployment
environment (development/staging/production)</p>
<pre><code>// OTLP exporter settings
OTLPExporterEndpoint string // Collector endpoint (host:port)
OTLPExporterInsecure bool   // Disable TLS verification
OTLPExporterProtocol string // Protocol for OTLP exporter (default: grpc)

// Batch processing configuration
BatchTimeout       time.Duration // Timeout for batch processing (default: 5s)
ExportTimeout      time.Duration // Timeout for export requests (default: 30s)
MaxExportBatchSize int           // Maximum batch size for exports (default: 512)
MaxQueueSize       int           // Maximum queue size for spans (default: 2048)

// Sampling configuration
SamplingRatio float64 // Ratio of traces to sample (0.0 - 1.0)
SamplingType  string  // Sampling strategy

// Resource attributes
InstanceID string // Unique instance identifier
Hostname   string // Host machine name</code></pre>
<p>} Config defines tracing configuration parameters</p>
<p>func NewConfig(serviceName, serviceVersion string) *Config NewConfig
creates a configuration with sensible defaults</p>
<p>func NewConfigFromEnv() *Config NewConfigFromEnv creates
configuration from environment variables</p>
<p>func (c *Config) Validate() error Validate ensures configuration
parameters are correct</p>
<p>func (c <em>Config) WithEnvironment(env string) </em>Config
WithEnvironment sets the deployment environment</p>
<p>func (c <em>Config) WithOTLPExporter(endpoint string, insecure bool,
protocol string) </em>Config WithOTLPExporter configures the OTLP
exporter (endpoint, insecure mode, and protocol)</p>
<p>func (c <em>Config) WithSampling(samplingType string, ratio float64)
</em>Config WithSampling configures the sampling strategy</p>
<p>type ConfigError struct { Field string Message string } ConfigError
represents a validation error in configuration.</p>
<p>func (e *ConfigError) Error() string Error returns a string
representation of the error.</p>
<p>type HTTPMiddleware struct { // Has unexported fields. }
HTTPMiddleware provides HTTP middleware for automatic request tracing.
It extracts trace context from incoming requests, creates server spans,
and automatically records HTTP-specific attributes like method, URL,
status code, and user agent. The middleware handles trace context
propagation according to W3C Trace Context and B3 propagation
standards.</p>
<pre><code>The middleware is compatible with any HTTP framework that uses the standard
http.Handler interface.</code></pre>
<p>func NewHttpMiddleware(tracer <em>Tracer) </em>HTTPMiddleware
NewHttpMiddleware creates a new HTTPMiddleware instance using the
provided Tracer. The tracer will be used to create spans for all
incoming HTTP requests.</p>
<pre><code>Example:

    tracer := otelkit.New(&quot;http-service&quot;)
    middleware := tracer.NewHttpMiddleware(tracer)

    // With gorilla/mux
    r := mux.NewRouter()
    r.Use(middleware.Middleware)

    // With chi
    r := chi.NewRouter()
    r.Use(middleware.Middleware)

    // With standard http.ServeMux
    mux := http.NewServeMux()
    handler := middleware.Middleware(mux)</code></pre>
<p>func (m *HTTPMiddleware) Middleware(next http.Handler) http.Handler
Middleware returns an HTTP handler middleware function that
automatically traces incoming requests.</p>
<pre><code>The middleware performs the following operations:
 1. Extracts trace context from incoming request headers (supports W3C Trace
    Context and B3)
 2. Creates a new server span with operation name &quot;METHOD /path&quot;
 3. Adds standard HTTP attributes: method, URL, user agent
 4. Wraps the response writer to capture the HTTP status code
 5. Propagates the trace context to downstream handlers
 6. Records the final HTTP status code when the request completes

Example usage:

    middleware := tracer.NewHttpMiddleware(tracer)

    http.Handle(&quot;/api/&quot;, middleware.Middleware(apiHandler))

    // Or with a router:
    r := mux.NewRouter()
    r.Use(middleware.Middleware)
    r.HandleFunc(&quot;/users/{id}&quot;, getUserHandler)</code></pre>
<p>type InitializationError struct { Component string Cause error }
InitializationError wraps failures during component setup.</p>
<p>func (e *InitializationError) Error() string Error returns a string
representation of the error.</p>
<p>func (e *InitializationError) Unwrap() error Unwrap returns the
underlying error.</p>
<p>type PropagationError struct { Operation string Cause error }
PropagationError wraps errors related to context propagation.</p>
<p>func (e *PropagationError) Error() string Error returns a string
representation of the error.</p>
<p>func (e *PropagationError) Unwrap() error Unwrap returns the
underlying error.</p>
<p>type ProviderConfig struct { // Config contains the core tracing
configuration including service identification, // exporter settings,
and sampling strategy. Config *Config</p>
<pre><code>// Resource provides custom resource attributes for service identification.
// If nil, a default resource will be created using service name, version,
// environment, hostname, and instance ID from Config.
Resource *sdkresource.Resource

// BatchTimeout is the maximum time the batch processor waits before
// exporting spans. Lower values reduce latency but may increase overhead.
// Default: 5 seconds.
BatchTimeout time.Duration

// ExportTimeout is the maximum time allowed for exporting a batch of spans.
// Exports exceeding this timeout will be cancelled. Default: 30 seconds.
ExportTimeout time.Duration

// MaxExportBatchSize is the maximum number of spans to export in a single batch.
// Larger batches improve throughput but use more memory. Default: 512.
MaxExportBatchSize int

// MaxQueueSize is the maximum number of spans that can be queued for export.
// When the queue is full, new spans will be dropped. Default: 2048.
MaxQueueSize int</code></pre>
<p>} ProviderConfig holds comprehensive configuration for creating a
TracerProvider. It combines basic tracing configuration with advanced
options for batch processing, resource identification, and performance
tuning. This allows fine-grained control over the tracing pipeline
behavior.</p>
<pre><code>The configuration supports fluent method chaining for ease of use:

    config := tracer.NewProviderConfig(&quot;my-service&quot;, &quot;v1.0.0&quot;).
        WithOTLPExporter(&quot;localhost:4317&quot;, &quot;grpc&quot;, true).
        WithSampling(&quot;probabilistic&quot;, 0.1).
        WithBatchOptions(5*time.Second, 30*time.Second, 512, 2048)</code></pre>
<p>func NewProviderConfig(serviceName, serviceVersion string)
*ProviderConfig NewProviderConfig creates a new ProviderConfig with
sensible defaults for advanced configuration. It initializes the
configuration with default batch processing settings and creates a base
Config using the provided service name and version. The returned config
supports fluent method chaining for customization.</p>
<pre><code>Default settings:
  - BatchTimeout: 5 seconds
  - ExportTimeout: 30 seconds
  - MaxExportBatchSize: 512 spans
  - MaxQueueSize: 2048 spans
  - OTLP HTTP exporter pointing to localhost:4318
  - Probabilistic sampling at 20%

Example:

    config := tracer.NewProviderConfig(&quot;user-service&quot;, &quot;v2.1.0&quot;)
    provider, err := tracer.NewProvider(ctx, config)</code></pre>
<p>func (pc <em>ProviderConfig) WithBatchOptions(batchTimeout,
exportTimeout time.Duration, maxExportBatchSize, maxQueueSize int)
</em>ProviderConfig WithBatchOptions configures the batch processor
settings for span export optimization. These settings control how spans
are batched and exported, affecting both performance and resource usage.
Tune these values based on your application’s traffic patterns and
latency requirements.</p>
<pre><code>Parameters:
  - batchTimeout: Maximum time to wait before exporting (lower = less
    latency, higher = better throughput)
  - exportTimeout: Maximum time allowed for export operations (prevents
    hanging exports)
  - maxExportBatchSize: Maximum spans per batch (higher = better throughput,
    more memory usage)
  - maxQueueSize: Maximum queued spans before dropping (higher = more
    memory, less data loss)

Example:

    // Low-latency configuration
    config.WithBatchOptions(1*time.Second, 10*time.Second, 256, 1024)

    // High-throughput configuration
    config.WithBatchOptions(10*time.Second, 60*time.Second, 1024, 4096)</code></pre>
<p>func (pc <em>ProviderConfig) WithOTLPExporter(endpoint, protocol
string, insecure bool) </em>ProviderConfig WithOTLPExporter configures
the OTLP exporter settings for trace export. This method allows you to
specify the endpoint, protocol, and security settings for sending traces
to an OTLP-compatible backend.</p>
<pre><code>Parameters:
  - endpoint: The URL or address of the OTLP collector (e.g.,
    &quot;localhost:4317&quot;, &quot;https://api.honeycomb.io&quot;)
  - protocol: Either &quot;grpc&quot; for gRPC transport or &quot;http&quot; for HTTP transport
  - insecure: true to disable TLS (for development), false to use TLS (for
    production)

Example:

    config.WithOTLPExporter(&quot;https://api.honeycomb.io&quot;, &quot;http&quot;, false)
    config.WithOTLPExporter(&quot;localhost:4317&quot;, &quot;grpc&quot;, true)  // Development</code></pre>
<p>func (pc <em>ProviderConfig) WithResource(resource
</em>sdkresource.Resource) *ProviderConfig WithResource sets a custom
OpenTelemetry resource for service identification. Resources contain
attributes that identify the service, version, environment, and other
metadata. If not provided, a default resource will be created
automatically using the service name, version, and other attributes from
the Config.</p>
<pre><code>Example:

    resource, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(&quot;payment-service&quot;),
            semconv.ServiceVersion(&quot;v1.2.3&quot;),
            semconv.DeploymentEnvironment(&quot;production&quot;),
            attribute.String(&quot;region&quot;, &quot;us-west-2&quot;),
        ),
    )
    config.WithResource(resource)</code></pre>
<p>func (pc <em>ProviderConfig) WithSampling(samplingType string, ratio
float64) </em>ProviderConfig WithSampling configures the sampling
strategy and ratio for trace collection. Sampling controls what
percentage of traces are collected and exported, which is crucial for
managing overhead in high-traffic applications.</p>
<pre><code>Parameters:
  - samplingType: &quot;probabilistic&quot; (ratio-based), &quot;always_on&quot; (100%),
    or &quot;always_off&quot; (0%)
  - ratio: For probabilistic sampling, the ratio of traces to sample (0.0 to
    1.0) Ignored for &quot;always_on&quot; and &quot;always_off&quot; strategies

Example:

    config.WithSampling(&quot;probabilistic&quot;, 0.01)  // 1% sampling for production
    config.WithSampling(&quot;always_on&quot;, 0)        // 100% sampling for development
    config.WithSampling(&quot;always_off&quot;, 0)       // Disable tracing</code></pre>
<p>type Tracer struct { // Has unexported fields. } Tracer wraps
OpenTelemetry tracer with convenience methods for easier tracing
operations. It provides a simplified interface for creating spans,
adding attributes, and managing trace context while maintaining full
compatibility with OpenTelemetry standards.</p>
<pre><code>Example usage:

    tracer := otelkit.New(&quot;my-service&quot;)
    ctx, span := tracer.Start(ctx, &quot;operation-name&quot;)
    defer span.End()
    // ... your code here</code></pre>
<p>func New(name string) *Tracer New creates a new Tracer instance with
the specified name. The name is used to identify the tracer and appears
in telemetry data. It’s recommended to use your service or component
name.</p>
<pre><code>Example:

    tracer := otelkit.New(&quot;user-service&quot;)
    tracer := otelkit.New(&quot;payment-processor&quot;)</code></pre>
<p>func (t *Tracer) GetTraceID(ctx context.Context) string GetTraceID
extracts and returns the trace ID from the current span context. Returns
an empty string if no valid span is found in the context. This is useful
for correlation logging and debugging.</p>
<pre><code>Example:

    traceID := tracer.GetTraceID(ctx)
    log.WithField(&quot;trace_id&quot;, traceID).Info(&quot;Processing request&quot;)</code></pre>
<p>func (t *Tracer) OtelTracer() trace.Tracer OtelTracer returns the
underlying OpenTelemetry tracer instance. This is useful when you need
direct access to OpenTelemetry APIs or when integrating with other
OpenTelemetry-compatible libraries.</p>
<pre><code>Example:

    otelTracer := tracer.OtelTracer()
    // Use with other OpenTelemetry libraries</code></pre>
<p>func (t *Tracer) Start(ctx context.Context, name string, opts
…trace.SpanStartOption) (context.Context, trace.Span) Start creates a
new span with the given name and options. Returns a new context
containing the span and the span itself. The span must be ended by
calling span.End() when the operation completes.</p>
<pre><code>Example:

    ctx, span := tracer.Start(ctx, &quot;database-query&quot;)
    defer span.End()
    // ... perform database operation</code></pre>
<p>func (t *Tracer) StartClientSpan(ctx context.Context, operation
string, attrs …attribute.KeyValue) (context.Context, trace.Span)
StartClientSpan creates a new client span for outgoing requests or
operations. This is a convenience method that automatically sets the
span kind to SpanKindClient and adds the provided attributes. Use this
for HTTP client requests, gRPC client calls, database queries, external
API calls, etc.</p>
<pre><code>Example:

    ctx, span := tracer.StartClientSpan(ctx, &quot;call-payment-api&quot;,
        attribute.String(&quot;http.method&quot;, &quot;POST&quot;),
        attribute.String(&quot;http.url&quot;, &quot;https://api.payment.com/charge&quot;),
    )
    defer span.End()</code></pre>
<p>func (t *Tracer) StartServerSpan(ctx context.Context, operation
string, attrs …attribute.KeyValue) (context.Context, trace.Span)
StartServerSpan creates a new server span for incoming requests or
operations. This is a convenience method that automatically sets the
span kind to SpanKindServer and adds the provided attributes. Use this
for HTTP handlers, gRPC server methods, message queue consumers,
etc.</p>
<pre><code>Example:

    ctx, span := tracer.StartServerSpan(ctx, &quot;handle-user-request&quot;,
        attribute.String(&quot;user.id&quot;, userID),
        attribute.String(&quot;request.method&quot;, &quot;POST&quot;),
    )
    defer span.End()</code></pre>
<p>Generated on Sun Aug 24 06:06:11 UTC 2025</p>
